"""
Plot TOV Evolution Data

This script reads HDF5 files generated by TOVEvolution.py and creates
plots and videos showing the evolution of:
1. Conservative variables (D, Sr, tau) vs r
2. Primitive variables (rho0, p, vr, W) vs r
3. BSSN variables vs r
4. Time series (rho_central, errors, mass) vs t

Usage:
    python plot_TOVEvolution.py [data_directory]

Example:
    python plot_TOVEvolution.py tov_evolution_data
"""

import numpy as np
import h5py
import json
import os
import sys
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.gridspec import GridSpec
from glob import glob
from scipy import signal
from scipy.fft import fft, fftfreq
from scipy.signal import find_peaks, butter, filtfilt
from scipy.optimize import curve_fit

# Get script directory for output
script_dir = os.path.dirname(os.path.abspath(__file__))
plots_dir = os.path.join(script_dir, 'plots')

# Check for available video writers
VIDEO_WRITER = 'pillow'  # Default to GIF (always available)
VIDEO_EXT = '.gif'

try:
    import subprocess
    try:
        subprocess.run(['ffmpeg', '-version'], capture_output=True, check=True)
        VIDEO_WRITER = 'ffmpeg'
        VIDEO_EXT = '.mp4'
        print("Using ffmpeg for video output (MP4)")
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("ffmpeg not found. Using pillow for GIF output")
except ImportError:
    print("Using pillow for GIF output")


def load_metadata(data_dir, suffix=""):
    """Load simulation metadata.

    Args:
        data_dir: Directory containing data files
        suffix: File suffix for coordinate system (e.g., "_iso")
    """
    pattern = os.path.join(data_dir, f'tov_metadata{suffix}_*.json')
    metadata_files = glob(pattern)
    if not metadata_files:
        raise FileNotFoundError(f"No metadata file found in {data_dir} with suffix '{suffix}'")

    metadata_file = sorted(metadata_files)[-1]
    with open(metadata_file, 'r') as f:
        metadata = json.load(f)

    print(f"Loaded metadata from: {metadata_file}")
    return metadata


def load_snapshot_data(data_dir, suffix=""):
    """Load all snapshot data from HDF5 file.

    Args:
        data_dir: Directory containing data files
        suffix: File suffix for coordinate system (e.g., "_iso")
    """
    pattern = os.path.join(data_dir, f'tov_snapshots{suffix}_*.h5')
    snapshot_files = glob(pattern)
    if not snapshot_files:
        raise FileNotFoundError(f"No snapshot file found in {data_dir} with suffix '{suffix}'")

    snapshot_file = sorted(snapshot_files)[-1]
    print(f"Loading snapshots from: {snapshot_file}")

    snapshots = []
    with h5py.File(snapshot_file, 'r') as f:
        # Get grid
        r = f['grid/r'][:]

        # Get all snapshot names and sort them
        snap_names = sorted([k for k in f['snapshots'].keys()],
                           key=lambda x: int(x.split('_')[1]))

        print(f"Found {len(snap_names)} snapshots")

        for snap_name in snap_names:
            snap = f['snapshots'][snap_name]

            snapshot_data = {
                'step': snap.attrs['step'],
                'time': snap.attrs['time'],
                'r': r,
            }

            # Load conservatives
            if 'conservatives' in snap:
                snapshot_data['D'] = snap['conservatives/D'][:]
                snapshot_data['Sr'] = snap['conservatives/Sr'][:]
                snapshot_data['tau'] = snap['conservatives/tau'][:]

            # Load BSSN variables
            if 'bssn' in snap:
                for key in snap['bssn'].keys():
                    snapshot_data[f'bssn_{key}'] = snap['bssn'][key][:]

            # Load primitives if available
            if 'primitives' in snap:
                for key in snap['primitives'].keys():
                    snapshot_data[key] = snap['primitives'][key][:]

            snapshots.append(snapshot_data)

    return snapshots


def load_evolution_data(data_dir, suffix=""):
    """Load evolution time series from HDF5 file.

    Args:
        data_dir: Directory containing data files
        suffix: File suffix for coordinate system (e.g., "_iso")
    """
    pattern = os.path.join(data_dir, f'tov_evolution{suffix}_*.h5')
    evolution_files = glob(pattern)
    if not evolution_files:
        print(f"Warning: No evolution file found with suffix '{suffix}'")
        return None

    evolution_file = sorted(evolution_files)[-1]
    print(f"Loading evolution data from: {evolution_file}")

    evolution = {}
    with h5py.File(evolution_file, 'r') as f:
        for key in f.keys():
            evolution[key] = f[key][:]

    return evolution


def plot_snapshot_profiles(snapshots, R_star, output_dir, indices=None, suffix=""):
    """Create static plots of profiles at selected snapshots.

    Args:
        snapshots: List of snapshot dictionaries
        R_star: Stellar radius
        output_dir: Output directory
        indices: Indices of snapshots to plot
        suffix: File suffix for coordinate system (e.g., "_iso")
    """
    print("\nCreating snapshot profile plots...")

    if indices is None:
        # Select initial, middle, and final snapshots
        n = len(snapshots)
        if n >= 4:
            indices = [0, n//3, 2*n//3, n-1]
        elif n >= 2:
            indices = [0, n-1]
        else:
            indices = [0]

    r = snapshots[0]['r']

    # --- Conservative Variables ---
    fig, axes = plt.subplots(1, 3, figsize=(15, 4))

    colors = plt.cm.viridis(np.linspace(0, 1, len(indices)))

    for i, idx in enumerate(indices):
        snap = snapshots[idx]
        t = snap['time']
        label = f't={t:.3f}'

        if 'D' in snap:
            axes[0].semilogy(r, np.maximum(snap['D'], 1e-20), color=colors[i],
                           linewidth=1.5, label=label)
        if 'Sr' in snap:
            axes[1].plot(r, snap['Sr'], color=colors[i], linewidth=1.5, label=label)
        if 'tau' in snap:
            axes[2].semilogy(r, np.maximum(np.abs(snap['tau']), 1e-20), color=colors[i],
                           linewidth=1.5, label=label)

    for ax in axes:
        ax.axvline(R_star, color='gray', ls='--', alpha=0.5, label=f'R*={R_star:.2f}')
        ax.grid(True, alpha=0.3)
        ax.legend(fontsize=8)
        ax.set_xlabel('r [M]')

    axes[0].set_ylabel('D')
    axes[0].set_title('Conserved Density D')
    axes[1].set_ylabel('Sr')
    axes[1].set_title('Conserved Momentum Sr')
    axes[2].set_ylabel('|τ|')
    axes[2].set_title('Conserved Energy |τ|')

    plt.tight_layout()
    out_path = os.path.join(output_dir, f'conservative_profiles{suffix}.png')
    plt.savefig(out_path, dpi=150, bbox_inches='tight')
    plt.close(fig)
    print(f"Saved: {out_path}")

    # --- Primitive Variables ---
    if 'rho0' in snapshots[0]:
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))

        for i, idx in enumerate(indices):
            snap = snapshots[idx]
            t = snap['time']
            label = f't={t:.3f}'

            axes[0, 0].semilogy(r, np.maximum(snap['rho0'], 1e-20), color=colors[i],
                               linewidth=1.5, label=label)
            axes[0, 1].semilogy(r, np.maximum(snap['p'], 1e-20), color=colors[i],
                               linewidth=1.5, label=label)
            axes[1, 0].plot(r, snap['vr'], color=colors[i], linewidth=1.5, label=label)
            if 'W' in snap:
                axes[1, 1].plot(r, snap['W'], color=colors[i], linewidth=1.5, label=label)

        for ax in axes.ravel():
            ax.axvline(R_star, color='gray', ls='--', alpha=0.5)
            ax.grid(True, alpha=0.3)
            ax.legend(fontsize=8)
            ax.set_xlabel('r [M]')

        axes[0, 0].set_ylabel('ρ₀')
        axes[0, 0].set_title('Baryon Density ρ₀')
        axes[0, 1].set_ylabel('P')
        axes[0, 1].set_title('Pressure P')
        axes[1, 0].set_ylabel('vʳ')
        axes[1, 0].set_title('Radial Velocity vʳ')
        axes[1, 1].set_ylabel('W')
        axes[1, 1].set_title('Lorentz Factor W')

        plt.tight_layout()
        out_path = os.path.join(output_dir, f'primitive_profiles{suffix}.png')
        plt.savefig(out_path, dpi=150, bbox_inches='tight')
        plt.close(fig)
        print(f"Saved: {out_path}")

    # --- BSSN Variables ---
    bssn_keys = [k for k in snapshots[0].keys() if k.startswith('bssn_')]
    if bssn_keys:
        n_bssn = len(bssn_keys)
        ncols = 3
        nrows = (n_bssn + ncols - 1) // ncols

        fig, axes = plt.subplots(nrows, ncols, figsize=(15, 4*nrows))
        axes = axes.ravel() if n_bssn > 1 else [axes]

        for j, bssn_key in enumerate(sorted(bssn_keys)):
            ax = axes[j]
            var_name = bssn_key.replace('bssn_', '')

            for i, idx in enumerate(indices):
                snap = snapshots[idx]
                t = snap['time']
                ax.plot(r, snap[bssn_key], color=colors[i], linewidth=1.5,
                       label=f't={t:.3f}')

            ax.axvline(R_star, color='gray', ls='--', alpha=0.5)
            ax.grid(True, alpha=0.3)
            ax.legend(fontsize=8)
            ax.set_xlabel('r [M]')
            ax.set_ylabel(var_name)
            ax.set_title(f'BSSN: {var_name}')

        # Hide unused axes
        for j in range(len(bssn_keys), len(axes)):
            axes[j].set_visible(False)

        plt.tight_layout()
        out_path = os.path.join(output_dir, 'bssn_profiles.png')
        plt.savefig(out_path, dpi=150, bbox_inches='tight')
        plt.close(fig)
        print(f"Saved: {out_path}")


def plot_evolution_timeseries(evolution, metadata, output_dir, suffix=""):
    """Create time series plots from evolution data."""
    print("\nCreating time series plots...")

    if evolution is None:
        print("No evolution data available")
        return

    t = evolution.get('time', None)
    if t is None:
        print("No time data in evolution")
        return

    fig = plt.figure(figsize=(14, 10))
    gs = GridSpec(2, 2, figure=fig, hspace=0.3, wspace=0.3)

    # Central density
    ax1 = fig.add_subplot(gs[0, 0])
    if 'rho_central' in evolution:
        rho_c = evolution['rho_central']
        rho_c0 = rho_c[0] if len(rho_c) > 0 else 1.0
        ax1.plot(t, rho_c / rho_c0, 'b-', linewidth=1.5)
        ax1.axhline(1.0, color='gray', ls='--', alpha=0.5)
        ax1.set_xlabel('Time t [M]')
        ax1.set_ylabel('ρ_c / ρ_c(0)')
        ax1.set_title('Central Density Evolution')
        ax1.grid(True, alpha=0.3)

    # L1 and L2 density errors
    ax2 = fig.add_subplot(gs[0, 1])
    if 'l1_rho_error' in evolution:
        ax2.semilogy(t, evolution['l1_rho_error'], 'b-', linewidth=1.5, label='L1')
    if 'l2_rho_error' in evolution:
        ax2.semilogy(t, evolution['l2_rho_error'], 'r-', linewidth=1.5, label='L2')
    ax2.set_xlabel('Time t [M]')
    ax2.set_ylabel('Error')
    ax2.set_title('Density Error Norms')
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    # Maximum velocity
    ax3 = fig.add_subplot(gs[1, 0])
    if 'max_velocity' in evolution:
        ax3.semilogy(t, evolution['max_velocity'], 'g-', linewidth=1.5)
        ax3.set_xlabel('Time t [M]')
        ax3.set_ylabel('max |vʳ|')
        ax3.set_title('Maximum Velocity')
        ax3.grid(True, alpha=0.3)

    # Maximum relative errors
    ax4 = fig.add_subplot(gs[1, 1])
    if 'max_rho_error' in evolution:
        ax4.semilogy(t, evolution['max_rho_error'], 'b-', linewidth=1.5, label='ρ')
    if 'max_p_error' in evolution:
        ax4.semilogy(t, evolution['max_p_error'], 'r-', linewidth=1.5, label='P')
    ax4.set_xlabel('Time t [M]')
    ax4.set_ylabel('max |Δ/ref|')
    ax4.set_title('Maximum Relative Errors')
    ax4.legend()
    ax4.grid(True, alpha=0.3)

    plt.suptitle('TOV Evolution Time Series', fontsize=14, fontweight='bold')
    plt.tight_layout()
    out_path = os.path.join(output_dir, f'evolution_timeseries{suffix}.png')
    plt.savefig(out_path, dpi=150, bbox_inches='tight')
    plt.close(fig)
    print(f"Saved: {out_path}")

    # Additional plot: conservative variable maxima
    fig, axes = plt.subplots(1, 3, figsize=(15, 4))

    if 'max_D' in evolution:
        axes[0].plot(t, evolution['max_D'], 'b-', linewidth=1.5)
        axes[0].set_ylabel('max D')
        axes[0].set_title('Maximum D')

    if 'max_Sr' in evolution:
        axes[1].semilogy(t, np.maximum(evolution['max_Sr'], 1e-20), 'r-', linewidth=1.5)
        axes[1].set_ylabel('max |Sr|')
        axes[1].set_title('Maximum |Sr|')

    if 'max_tau' in evolution:
        axes[2].plot(t, evolution['max_tau'], 'g-', linewidth=1.5)
        axes[2].set_ylabel('max τ')
        axes[2].set_title('Maximum τ')

    for ax in axes:
        ax.set_xlabel('Time t [M]')
        ax.grid(True, alpha=0.3)

    plt.tight_layout()
    out_path = os.path.join(output_dir, f'conservative_maxima{suffix}.png')
    plt.savefig(out_path, dpi=150, bbox_inches='tight')
    plt.close(fig)
    print(f"Saved: {out_path}")


def create_conservative_video(snapshots, R_star, output_dir, suffix=""):
    """Create video of conservative variables evolution.

    Args:
        snapshots: List of snapshot dictionaries
        R_star: Stellar radius
        output_dir: Output directory
        suffix: File suffix for coordinate system (e.g., "_iso")
    """
    print("\nCreating conservative variables video...")

    fig = plt.figure(figsize=(10, 12))
    gs = GridSpec(3, 1, figure=fig, hspace=0.35, top=0.93)

    ax1 = fig.add_subplot(gs[0, 0])
    ax2 = fig.add_subplot(gs[1, 0])
    ax3 = fig.add_subplot(gs[2, 0])

    r = snapshots[0]['r']

    # Initialize lines
    line_D, = ax1.semilogy([], [], 'b-', linewidth=2, label='D')
    ax1.axvline(R_star, color='gray', linestyle='--', linewidth=1.5,
                alpha=0.7, label=f'R*={R_star:.3f}')
    ax1.set_xlabel('r [M]', fontsize=11)
    ax1.set_ylabel('D', fontsize=11)
    ax1.set_title('Conserved Density', fontsize=12, fontweight='bold')
    ax1.grid(True, alpha=0.3)
    ax1.legend(loc='upper right')
    ax1.set_xlim(r[0], r[-1])

    line_Sr, = ax2.plot([], [], 'r-', linewidth=2, label='Sr')
    ax2.axvline(R_star, color='gray', linestyle='--', linewidth=1.5, alpha=0.7)
    ax2.set_xlabel('r [M]', fontsize=11)
    ax2.set_ylabel('Sr', fontsize=11)
    ax2.set_title('Conserved Radial Momentum', fontsize=12, fontweight='bold')
    ax2.grid(True, alpha=0.3)
    ax2.legend(loc='upper right')
    ax2.set_xlim(r[0], r[-1])

    line_tau, = ax3.semilogy([], [], 'g-', linewidth=2, label='τ')
    ax3.axvline(R_star, color='gray', linestyle='--', linewidth=1.5, alpha=0.7)
    ax3.set_xlabel('r [M]', fontsize=11)
    ax3.set_ylabel('τ', fontsize=11)
    ax3.set_title('Conserved Energy', fontsize=12, fontweight='bold')
    ax3.grid(True, alpha=0.3)
    ax3.legend(loc='upper right')
    ax3.set_xlim(r[0], r[-1])

    # Compute y-limits from all snapshots
    D_min, D_max = 1e10, -1e10
    Sr_min, Sr_max = 1e10, -1e10
    tau_min, tau_max = 1e10, -1e10

    for snap in snapshots:
        if 'D' in snap:
            D_pos = snap['D'][snap['D'] > 0]
            if len(D_pos) > 0:
                D_min = min(D_min, np.min(D_pos))
                D_max = max(D_max, np.max(D_pos))
        if 'Sr' in snap:
            Sr_min = min(Sr_min, np.min(snap['Sr']))
            Sr_max = max(Sr_max, np.max(snap['Sr']))
        if 'tau' in snap:
            tau_pos = np.abs(snap['tau'])
            tau_pos = tau_pos[tau_pos > 0]
            if len(tau_pos) > 0:
                tau_min = min(tau_min, np.min(tau_pos))
                tau_max = max(tau_max, np.max(tau_pos))

    if D_max > D_min:
        ax1.set_ylim(D_min * 0.5, D_max * 2.0)
    if Sr_max > Sr_min:
        margin = max(abs(Sr_min), abs(Sr_max)) * 0.2
        ax2.set_ylim(Sr_min - margin, Sr_max + margin)
    if tau_max > tau_min:
        ax3.set_ylim(tau_min * 0.5, tau_max * 2.0)

    time_text = fig.suptitle('', fontsize=14, fontweight='bold', y=0.98)

    def init():
        line_D.set_data([], [])
        line_Sr.set_data([], [])
        line_tau.set_data([], [])
        time_text.set_text('')
        return line_D, line_Sr, line_tau, time_text

    def animate(i):
        snap = snapshots[i]
        if 'D' in snap:
            line_D.set_data(snap['r'], snap['D'])
        if 'Sr' in snap:
            line_Sr.set_data(snap['r'], snap['Sr'])
        if 'tau' in snap:
            line_tau.set_data(snap['r'], np.abs(snap['tau']))
        time_text.set_text(f"t = {snap['time']:.4f} M (step {snap['step']})")
        return line_D, line_Sr, line_tau, time_text

    anim = animation.FuncAnimation(fig, animate, init_func=init,
                                   frames=len(snapshots), interval=50, blit=False)

    output_file = os.path.join(output_dir, f'conservative_evolution{suffix}{VIDEO_EXT}')
    anim.save(output_file, writer=VIDEO_WRITER, fps=20, dpi=100)
    print(f"Saved: {output_file}")
    plt.close(fig)


def create_primitive_video(snapshots, R_star, output_dir, suffix=""):
    """Create video of primitive variables evolution.

    Args:
        snapshots: List of snapshot dictionaries
        R_star: Stellar radius
        output_dir: Output directory
        suffix: File suffix for coordinate system (e.g., "_iso")
    """
    print("\nCreating primitive variables video...")

    if 'rho0' not in snapshots[0]:
        print("Warning: Primitive variables not found in snapshots. Skipping.")
        return

    fig = plt.figure(figsize=(14, 10))
    gs = GridSpec(2, 2, figure=fig, hspace=0.35, wspace=0.3, top=0.93)

    ax1 = fig.add_subplot(gs[0, 0])
    ax2 = fig.add_subplot(gs[0, 1])
    ax3 = fig.add_subplot(gs[1, 0])
    ax4 = fig.add_subplot(gs[1, 1])

    r = snapshots[0]['r']

    # Initialize lines
    line_rho, = ax1.semilogy([], [], 'b-', linewidth=2, label='ρ₀')
    ax1.axvline(R_star, color='gray', linestyle='--', linewidth=1.5, alpha=0.7)
    ax1.set_xlabel('r [M]')
    ax1.set_ylabel('ρ₀')
    ax1.set_title('Baryon Density', fontweight='bold')
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    ax1.set_xlim(r[0], r[-1])

    line_p, = ax2.semilogy([], [], 'r-', linewidth=2, label='P')
    ax2.axvline(R_star, color='gray', linestyle='--', linewidth=1.5, alpha=0.7)
    ax2.set_xlabel('r [M]')
    ax2.set_ylabel('P')
    ax2.set_title('Pressure', fontweight='bold')
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    ax2.set_xlim(r[0], r[-1])

    line_vr, = ax3.plot([], [], 'g-', linewidth=2, label='vʳ')
    ax3.axvline(R_star, color='gray', linestyle='--', linewidth=1.5, alpha=0.7)
    ax3.axhline(0, color='k', ls=':', alpha=0.3)
    ax3.set_xlabel('r [M]')
    ax3.set_ylabel('vʳ')
    ax3.set_title('Radial Velocity', fontweight='bold')
    ax3.grid(True, alpha=0.3)
    ax3.legend()
    ax3.set_xlim(r[0], r[-1])

    line_W, = ax4.plot([], [], 'm-', linewidth=2, label='W')
    ax4.axvline(R_star, color='gray', linestyle='--', linewidth=1.5, alpha=0.7)
    ax4.set_xlabel('r [M]')
    ax4.set_ylabel('W')
    ax4.set_title('Lorentz Factor', fontweight='bold')
    ax4.grid(True, alpha=0.3)
    ax4.legend()
    ax4.set_xlim(r[0], r[-1])

    # Compute y-limits
    rho_min, rho_max = 1e10, -1e10
    p_min, p_max = 1e10, -1e10
    vr_min, vr_max = 1e10, -1e10
    W_min, W_max = 1e10, -1e10

    for snap in snapshots:
        rho_pos = snap['rho0'][snap['rho0'] > 0]
        if len(rho_pos) > 0:
            rho_min = min(rho_min, np.min(rho_pos))
            rho_max = max(rho_max, np.max(rho_pos))

        p_pos = snap['p'][snap['p'] > 0]
        if len(p_pos) > 0:
            p_min = min(p_min, np.min(p_pos))
            p_max = max(p_max, np.max(p_pos))

        vr_min = min(vr_min, np.min(snap['vr']))
        vr_max = max(vr_max, np.max(snap['vr']))

        if 'W' in snap:
            W_min = min(W_min, np.min(snap['W']))
            W_max = max(W_max, np.max(snap['W']))

    ax1.set_ylim(rho_min * 0.5, rho_max * 2.0)
    ax2.set_ylim(p_min * 0.5, p_max * 2.0)
    margin_v = max(abs(vr_min), abs(vr_max)) * 0.2
    ax3.set_ylim(vr_min - margin_v, vr_max + margin_v)
    ax4.set_ylim(W_min * 0.95, W_max * 1.05)

    time_text = fig.suptitle('', fontsize=14, fontweight='bold', y=0.98)

    def init():
        line_rho.set_data([], [])
        line_p.set_data([], [])
        line_vr.set_data([], [])
        line_W.set_data([], [])
        time_text.set_text('')
        return line_rho, line_p, line_vr, line_W, time_text

    def animate(i):
        snap = snapshots[i]
        line_rho.set_data(snap['r'], np.maximum(snap['rho0'], 1e-20))
        line_p.set_data(snap['r'], np.maximum(snap['p'], 1e-20))
        line_vr.set_data(snap['r'], snap['vr'])
        if 'W' in snap:
            line_W.set_data(snap['r'], snap['W'])
        time_text.set_text(f"t = {snap['time']:.4f} M (step {snap['step']})")
        return line_rho, line_p, line_vr, line_W, time_text

    anim = animation.FuncAnimation(fig, animate, init_func=init,
                                   frames=len(snapshots), interval=50, blit=False)

    output_file = os.path.join(output_dir, f'primitive_evolution{suffix}{VIDEO_EXT}')
    anim.save(output_file, writer=VIDEO_WRITER, fps=20, dpi=100)
    print(f"Saved: {output_file}")
    plt.close(fig)


def print_summary(metadata, snapshots, evolution):
    """Print summary of loaded data."""
    print("\n" + "="*70)
    print("DATA SUMMARY")
    print("="*70)

    if metadata:
        tov = metadata.get('tov_solution', {})
        print(f"  TOV Solution:")
        print(f"    M* = {tov.get('M_star', 'N/A')}")
        print(f"    R* = {tov.get('R', 'N/A')}")
        print(f"    C  = {tov.get('C', 'N/A')}")
        print(f"    K  = {tov.get('K', 'N/A')}, Γ = {tov.get('Gamma', 'N/A')}")

        sim = metadata.get('simulation', {})
        print(f"  Simulation:")
        print(f"    dt = {sim.get('dt', 'N/A')}")
        print(f"    N  = {sim.get('grid_N', 'N/A')}")
        print(f"    r_max = {sim.get('grid_r_max', 'N/A')}")

    if snapshots:
        print(f"  Snapshots: {len(snapshots)}")
        print(f"    Time range: [{snapshots[0]['time']:.4f}, {snapshots[-1]['time']:.4f}] M")
        print(f"    Step range: [{snapshots[0]['step']}, {snapshots[-1]['step']}]")

        # List available variables
        available = []
        if 'D' in snapshots[0]:
            available.append('conservatives (D, Sr, τ)')
        if 'rho0' in snapshots[0]:
            available.append('primitives (ρ₀, P, vʳ, W, ε)')
        bssn_keys = [k for k in snapshots[0].keys() if k.startswith('bssn_')]
        if bssn_keys:
            available.append(f'BSSN ({len(bssn_keys)} vars)')
        print(f"    Variables: {', '.join(available)}")

    if evolution:
        print(f"  Evolution data: {len(evolution.get('time', []))} points")
        print(f"    Keys: {list(evolution.keys())}")

    print("="*70 + "\n")



# =============================================================================
# QNM ANALYSIS FUNCTIONS
# =============================================================================

def compute_qnm_spectrum(times_series, rho_c_series, output_dir='plots', suffix=""):
    """
    Compute and plot the quasi-normal mode frequency spectrum.

    This function performs a power spectral density (PSD) analysis of the
    central density evolution to identify quasi-normal mode frequencies,
    following the methodology in Guercilena et al. (2016) and Shum et al. (2024).

    Parameters:
    -----------
    times_series : array
        Time values in M_sun units (geometric units)
    rho_c_series : array
        Central density evolution
    output_dir : str
        Directory to save plots
    suffix : str
        Suffix for output filename (e.g., "_iso" for isotropic coordinates)

    Returns:
    --------
    freqs_kHz : array
        Frequency array in kHz
    psd_positive : array
        Power spectral density (positive frequencies only)
    peaks : array
        Indices of detected peaks in the spectrum
    """
    import matplotlib.pyplot as plt

    print("\n" + "="*70)
    print("QUASI-NORMAL MODE FREQUENCY ANALYSIS")
    print("="*70)

    # 1. Detrend data to remove any linear drift
    from scipy.signal import detrend
    rho_c_detrended = detrend(rho_c_series, type='linear')

    print(f"Signal length: {len(times_series)} points")
    print(f"Time span: {times_series[0]:.3e} to {times_series[-1]:.3e} (M_sun)")

    # 2. Apply window to reduce spectral leakage (Blackman window)
    window = signal.blackman(len(rho_c_detrended))
    rho_c_windowed = rho_c_detrended * window

    # 3. Compute FFT
    dt = times_series[1] - times_series[0]  # Uniform timestep assumed
    freqs = fftfreq(len(times_series), dt)  # Frequencies in 1/M_sun
    fft_vals = fft(rho_c_windowed)
    psd = np.abs(fft_vals)**2

    # 4. Keep only positive frequencies
    positive_mask = freqs > 0
    freqs_positive = freqs[positive_mask]
    psd_positive = psd[positive_mask]

    # 5. Convert frequencies from geometric units (1/M_sun) to physical units (kHz)
    # For M_sun: 1 M_sun = 4.926e-6 seconds
    # Angular frequency ω (rad/M_sun) = 2π * f (cycles/M_sun)
    # Frequency in Hz = ω / (2π * M_sun_to_sec)
    M_sun_to_sec = 4.926e-6
    freqs_kHz = freqs_positive / (2.0 * np.pi * M_sun_to_sec * 1000.0)

    print(f"Frequency resolution: {freqs_kHz[1] - freqs_kHz[0]:.3f} kHz")

    # 6. Find peaks in the spectrum
    # Use prominence-based detection to find significant peaks
    peaks, properties = find_peaks(psd_positive,
                                   height=np.max(psd_positive)*0.01,  # At least 1% of max
                                   distance=10,  # Minimum separation
                                   prominence=np.max(psd_positive)*0.005)

    # Sort peaks by power (descending)
    if len(peaks) > 0:
        peak_powers = psd_positive[peaks]
        sorted_idx = np.argsort(peak_powers)[::-1]
        peaks_sorted = peaks[sorted_idx]

        print(f"\nDetected {len(peaks)} significant peaks:")
        print(f"{'Mode':<10} {'Frequency (kHz)':<20} {'Power':<15}")
        print("-" * 45)

        mode_names = ['F-mode', 'H1', 'H2', 'H3', 'H4', 'H5']
        for i, peak_idx in enumerate(peaks_sorted[:min(6, len(peaks_sorted))]):
            mode_name = mode_names[i] if i < len(mode_names) else f'Mode {i+1}'
            freq_peak = freqs_kHz[peak_idx]
            power_peak = psd_positive[peak_idx]
            print(f"{mode_name:<10} {freq_peak:>10.3f} kHz      {power_peak:.3e}")
    else:
        print("\nNo significant peaks detected in the spectrum.")
        peaks_sorted = peaks

    # 7. Plot the spectrum
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

    # Full spectrum
    ax1.semilogy(freqs_kHz, psd_positive, 'b-', linewidth=0.8, label='PSD')
    if len(peaks_sorted) > 0:
        for i, peak_idx in enumerate(peaks_sorted[:6]):
            mode_name = mode_names[i] if i < len(mode_names) else f'Mode {i+1}'
            ax1.plot(freqs_kHz[peak_idx], psd_positive[peak_idx], 'ro', markersize=8)
            ax1.text(freqs_kHz[peak_idx], psd_positive[peak_idx]*1.5, mode_name,
                    ha='center', va='bottom', fontsize=9)

    ax1.set_xlabel('Frequency (kHz)', fontsize=11)
    ax1.set_ylabel('Power Spectral Density', fontsize=11)
    ax1.set_title('QNM Frequency Spectrum - Full Range', fontsize=12, fontweight='bold')
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # Zoomed spectrum (0-10 kHz, typical QNM range)
    zoom_mask = freqs_kHz < 10.0
    ax2.semilogy(freqs_kHz[zoom_mask], psd_positive[zoom_mask], 'b-', linewidth=0.8, label='PSD')
    if len(peaks_sorted) > 0:
        for i, peak_idx in enumerate(peaks_sorted[:6]):
            if freqs_kHz[peak_idx] < 10.0:
                mode_name = mode_names[i] if i < len(mode_names) else f'Mode {i+1}'
                ax2.plot(freqs_kHz[peak_idx], psd_positive[peak_idx], 'ro', markersize=8)
                ax2.text(freqs_kHz[peak_idx], psd_positive[peak_idx]*1.5, mode_name,
                        ha='center', va='bottom', fontsize=9)

    ax2.set_xlabel('Frequency (kHz)', fontsize=11)
    ax2.set_ylabel('Power Spectral Density', fontsize=11)
    ax2.set_title('QNM Frequency Spectrum - Zoom (0-10 kHz)', fontsize=12, fontweight='bold')
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    plt.tight_layout()
    plot_path = os.path.join(output_dir, f'tov_qnm_spectrum{suffix}.png')
    plt.savefig(plot_path, dpi=150, bbox_inches='tight')
    plt.close()

    print(f"\nSpectrum plot saved to: {plot_path}")

    # Expected values from literature (for reference)
    print("\n" + "-"*70)
    print("Reference values from Shum et al. (2024) - BDNK viscous hydro:")
    print("  F-mode: ~2.69 kHz")
    print("  H1:     ~4.55 kHz")
    print("  H2:     ~6.36 kHz")
    print("-"*70)

    return freqs_kHz, psd_positive, peaks_sorted


def extract_decay_rate(times_series, rho_c_series, f_mode_freq_kHz,
                       t_start=None, t_end=None, output_dir='plots', suffix=""):
    """
    Extract the decay rate of the fundamental mode (F-mode).

    This follows the procedure described in Shum et al. (2024), Section III.C.2:
    1. Bandpass filter around the F-mode frequency
    2. Select time window to avoid overtone contamination
    3. Fit to damped sinusoid: A * exp(-t/tau) * cos(omega*t + phi) + offset
    4. Extract decay time tau and decay rate 1/tau

    Parameters:
    -----------
    times_series : array
        Time values in M_sun units
    rho_c_series : array
        Central density evolution
    f_mode_freq_kHz : float
        F-mode frequency in kHz (from spectrum analysis)
    t_start : float, optional
        Start time for fitting window (M_sun). If None, starts after initial transient.
    t_end : float, optional
        End time for fitting window (M_sun). If None, uses full series.
    output_dir : str
        Directory to save plots
    suffix : str
        Suffix for output filename (e.g., "_iso" for isotropic coordinates)

    Returns:
    --------
    tau_fit : float
        Decay time in M_sun units
    decay_rate : float
        Decay rate (1/tau) in 1/M_sun units
    fitted_freq_kHz : float
        Fitted oscillation frequency in kHz
    """
    import matplotlib.pyplot as plt

    print("\n" + "="*70)
    print("F-MODE DECAY RATE EXTRACTION")
    print("="*70)
    print(f"Target F-mode frequency: {f_mode_freq_kHz:.3f} kHz")

    # 1. Detrend
    from scipy.signal import detrend
    rho_c_detrended = detrend(rho_c_series, type='linear')

    # 2. Design Butterworth bandpass filter around F-mode
    # Convert f_mode from kHz to geometric units (1/M_sun)
    M_sun_to_sec = 4.926e-6
    f_mode_geom = f_mode_freq_kHz * 1000.0 * 2.0 * np.pi * M_sun_to_sec  # rad/M_sun

    # Bandwidth: ±20% of central frequency
    bandwidth_factor = 0.2
    f_low_geom = f_mode_geom * (1.0 - bandwidth_factor)
    f_high_geom = f_mode_geom * (1.0 + bandwidth_factor)

    # Nyquist frequency
    dt = times_series[1] - times_series[0]
    f_nyquist = 1.0 / (2.0 * dt)  # In 1/M_sun

    # Normalized frequencies for butter filter
    f_low_norm = f_low_geom / f_nyquist
    f_high_norm = f_high_geom / f_nyquist

    # Safety check: ensure frequencies are in valid range (0, 1)
    if f_high_norm >= 1.0 or f_low_norm <= 0.0:
        print(f"Warning: Filter frequencies out of range. Adjusting...")
        f_low_norm = max(0.01, min(f_low_norm, 0.9))
        f_high_norm = min(0.99, max(f_high_norm, f_low_norm + 0.1))

    # Create filter
    filter_order = 4
    sos = butter(filter_order, [f_low_norm, f_high_norm], btype='bandpass', output='sos')
    rho_c_filtered = filtfilt(sos, rho_c_detrended)

    print(f"Bandpass filter: {f_low_geom/(2*np.pi*M_sun_to_sec*1000):.2f} - {f_high_geom/(2*np.pi*M_sun_to_sec*1000):.2f} kHz")

    # 3. Select time window for fitting
    # Skip initial transient (~10% of data) and use middle portion to avoid edge effects
    if t_start is None:
        t_start = times_series[len(times_series)//10]  # Skip first 10%
    if t_end is None:
        t_end = times_series[-len(times_series)//10]  # Skip last 10%

    fit_mask = (times_series >= t_start) & (times_series <= t_end)
    t_fit = times_series[fit_mask]
    rho_fit = rho_c_filtered[fit_mask]

    # Shift time to start from 0 for better numerical stability
    t_fit_shifted = t_fit - t_fit[0]

    print(f"Fitting window: t ∈ [{t_start:.3e}, {t_end:.3e}] M_sun ({np.sum(fit_mask)} points)")

    # 4. Fit to damped sinusoid: A * exp(-t/tau) * cos(omega*t + phi) + offset
    def damped_sinusoid(t, A, tau, omega, phi, offset):
        return A * np.exp(-t / tau) * np.cos(omega * t + phi) + offset

    # Initial guess
    A_guess = np.max(np.abs(rho_fit))
    tau_guess = (t_fit_shifted[-1] - t_fit_shifted[0]) / 2.0  # Half of time window
    omega_guess = f_mode_geom  # Use F-mode frequency
    phi_guess = 0.0
    offset_guess = np.mean(rho_fit)

    p0 = [A_guess, tau_guess, omega_guess, phi_guess, offset_guess]

    try:
        # Fit with bounds to ensure physical values
        bounds = (
            [0, 1e-3, f_low_geom, -2*np.pi, -np.inf],  # Lower bounds
            [np.inf, np.inf, f_high_geom, 2*np.pi, np.inf]  # Upper bounds
        )

        popt, pcov = curve_fit(damped_sinusoid, t_fit_shifted, rho_fit, p0=p0,
                              bounds=bounds, maxfev=10000)

        A_fit, tau_fit, omega_fit, phi_fit, offset_fit = popt

        # Compute fitted curve
        rho_fit_curve = damped_sinusoid(t_fit_shifted, *popt)

        # Convert to physical units
        decay_rate = 1.0 / tau_fit  # 1/M_sun
        decay_rate_kHz = decay_rate / (2.0 * np.pi * M_sun_to_sec * 1000.0)  # kHz
        fitted_freq_kHz = omega_fit / (2.0 * np.pi * M_sun_to_sec * 1000.0)  # kHz
        tau_fit_ms = tau_fit * M_sun_to_sec * 1000.0  # milliseconds

        # Goodness of fit
        residuals = rho_fit - rho_fit_curve
        ss_res = np.sum(residuals**2)
        ss_tot = np.sum((rho_fit - np.mean(rho_fit))**2)
        r_squared = 1.0 - (ss_res / ss_tot) if ss_tot > 0 else 0.0

        print(f"\nFit results:")
        print(f"  Amplitude:        A     = {A_fit:.6e}")
        print(f"  Decay time:       τ     = {tau_fit:.3e} M_sun = {tau_fit_ms:.3f} ms")
        print(f"  Decay rate:       1/τ   = {decay_rate:.3e} M_sun^-1 = {decay_rate_kHz:.3f} kHz")
        print(f"  Frequency:        f     = {fitted_freq_kHz:.3f} kHz")
        print(f"  Phase:            φ     = {phi_fit:.3f} rad")
        print(f"  Offset:           c     = {offset_fit:.6e}")
        print(f"  R²:                     = {r_squared:.6f}")

        fit_success = True

    except Exception as e:
        print(f"\nFit failed: {e}")
        print("Returning NaN values.")
        tau_fit = np.nan
        decay_rate = np.nan
        fitted_freq_kHz = np.nan
        rho_fit_curve = np.zeros_like(rho_fit)
        fit_success = False

    # 5. Plot results
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(14, 10))

    # Full signal
    ax1.plot(times_series, rho_c_detrended, 'b-', linewidth=0.8, alpha=0.7, label='Raw (detrended)')
    ax1.axvline(t_start, color='r', linestyle='--', alpha=0.5, label=f'Fit window')
    ax1.axvline(t_end, color='r', linestyle='--', alpha=0.5)
    ax1.set_xlabel('Time (M_sun)', fontsize=11)
    ax1.set_ylabel('δρ_c (detrended)', fontsize=11)
    ax1.set_title('Central Density Oscillation - Full Signal', fontsize=12, fontweight='bold')
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # Filtered signal
    ax2.plot(times_series, rho_c_filtered, 'g-', linewidth=0.8, alpha=0.7, label=f'Bandpass filtered ({f_mode_freq_kHz:.2f} kHz)')
    ax2.axvline(t_start, color='r', linestyle='--', alpha=0.5)
    ax2.axvline(t_end, color='r', linestyle='--', alpha=0.5)
    ax2.set_xlabel('Time (M_sun)', fontsize=11)
    ax2.set_ylabel('δρ_c (filtered)', fontsize=11)
    ax2.set_title(f'F-mode Filtered Signal ({f_mode_freq_kHz:.2f} kHz)', fontsize=12, fontweight='bold')
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    # Fit comparison
    if fit_success:
        ax3.plot(t_fit, rho_fit, 'g-', linewidth=1.5, alpha=0.7, label='Filtered data')
        ax3.plot(t_fit, rho_fit_curve, 'r--', linewidth=2, label=f'Fit: τ={tau_fit_ms:.2f} ms, f={fitted_freq_kHz:.2f} kHz')
        fit_label = f'Damped sinusoid fit (R²={r_squared:.4f})'
    else:
        ax3.plot(t_fit, rho_fit, 'g-', linewidth=1.5, alpha=0.7, label='Filtered data (fit failed)')
        fit_label = 'Fit failed'

    ax3.set_xlabel('Time (M_sun)', fontsize=11)
    ax3.set_ylabel('δρ_c (filtered)', fontsize=11)
    ax3.set_title(fit_label, fontsize=12, fontweight='bold')
    ax3.grid(True, alpha=0.3)
    ax3.legend()

    plt.tight_layout()
    plot_path = os.path.join(output_dir, f'tov_qnm_decay{suffix}.png')
    plt.savefig(plot_path, dpi=150, bbox_inches='tight')
    plt.close()

    print(f"\nDecay rate plot saved to: {plot_path}")

    return tau_fit, decay_rate, fitted_freq_kHz


def main():
    """Main function."""
    print("="*70)
    print("TOV Evolution Post-Processing")
    print("="*70)

    # Get data directory
    if len(sys.argv) > 1:
        data_dir = sys.argv[1]
        if not os.path.isabs(data_dir):
            # Try relative to script_dir first
            data_dir_script = os.path.join(script_dir, data_dir)
            if os.path.exists(data_dir_script):
                data_dir = data_dir_script
    else:
        # Default: look for tov_evolution_data in script directory
        data_dir = os.path.join(script_dir, 'tov_evolution_data')
        print(f"Using default data directory: {data_dir}")

    if not os.path.exists(data_dir):
        print(f"Error: Directory '{data_dir}' does not exist.")
        print(f"Usage: python {os.path.basename(__file__)} <data_directory>")
        sys.exit(1)

    # Create output directory inside data_dir
    output_dir = os.path.join(data_dir, 'plots')
    os.makedirs(output_dir, exist_ok=True)
    print(f"Output directory: {output_dir}\n")

    # Load data
    try:
        metadata = load_metadata(data_dir)
    except FileNotFoundError as e:
        print(f"Warning: {e}")
        metadata = {}

    try:
        snapshots = load_snapshot_data(data_dir)
    except FileNotFoundError as e:
        print(f"Error: {e}")
        sys.exit(1)

    evolution = load_evolution_data(data_dir)

    # Print summary
    print_summary(metadata, snapshots, evolution)

    # Get stellar radius
    R_star = metadata.get('tov_solution', {}).get('R', 10.0)
    print(f"Using stellar radius R* = {R_star:.4f}")

    # Create static plots
    print("\n" + "="*70)
    print("Creating plots...")
    print("="*70)

    plot_snapshot_profiles(snapshots, R_star, output_dir)
    plot_evolution_timeseries(evolution, metadata, output_dir)

    # Create videos (optional - can be slow)
    create_videos = True
    if create_videos and len(snapshots) > 1:
        print("\n" + "="*70)
        print("Creating videos...")
        print("="*70)
        create_conservative_video(snapshots, R_star, output_dir)
        create_primitive_video(snapshots, R_star, output_dir)

    print("\n" + "="*70)
    print("Post-processing complete!")
    print(f"Output saved in: {output_dir}")
    print("="*70)


if __name__ == "__main__":
    main()
